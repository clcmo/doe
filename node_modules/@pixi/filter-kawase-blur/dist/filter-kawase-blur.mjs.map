{"version":3,"file":"filter-kawase-blur.mjs","sources":["../src/KawaseBlurFilter.ts"],"sourcesContent":["import { vertex } from '@tools/fragments';\nimport fragment from './kawase-blur.frag';\nimport fragmentClamp from './kawase-blur-clamp.frag';\nimport { Filter, Point } from '@pixi/core';\nimport type { IPoint, CLEAR_MODES, FilterSystem, RenderTexture } from '@pixi/core';\n\ntype PixelSizeValue = IPoint | number[] | number;\n\n/**\n * A much faster blur than Gaussian blur, but more complicated to use.<br>\n * ![original](../tools/screenshots/dist/original.png)![filter](../tools/screenshots/dist/kawase-blur.png)\n *\n * @see https://software.intel.com/en-us/blogs/2014/07/15/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms\n * @class\n * @extends PIXI.Filter\n * @see {@link https://www.npmjs.com/package/@pixi/filter-kawase-blur|@pixi/filter-kawase-blur}\n * @see {@link https://www.npmjs.com/package/pixi-filters|pixi-filters}\n */\nclass KawaseBlurFilter extends Filter\n{\n    private _pixelSize: Point;\n    private _clamp: boolean;\n    private _kernels: number[] = [];\n    private _blur = 4;\n    private _quality = 3;\n\n    /**\n     * @param {number|number[]} [blur=4] - The blur of the filter. Should be greater than `0`. If\n     *        value is an Array, setting kernels.\n     * @param {number} [quality=3] - The quality of the filter. Should be an integer greater than `1`.\n     * @param {boolean} [clamp=false] - Clamp edges, useful for removing dark edges\n     *        from fullscreen filters or bleeding to the edge of filterArea.\n     */\n    constructor(blur: number | number[] = 4, quality = 3, clamp = false)\n    {\n        super(vertex, clamp ? fragmentClamp : fragment);\n        this.uniforms.uOffset = new Float32Array(2);\n\n        this._pixelSize = new Point();\n        this.pixelSize = 1;\n        this._clamp = clamp;\n\n        // if `blur` is array , as kernels\n        if (Array.isArray(blur))\n        {\n            this.kernels = blur;\n        }\n        else\n        {\n            this._blur = blur;\n            this.quality = quality;\n        }\n    }\n\n    /**\n     * Overrides apply\n     * @private\n     */\n    apply(filterManager: FilterSystem, input: RenderTexture, output: RenderTexture, clear: CLEAR_MODES): void\n    {\n        const uvX = this._pixelSize.x / input._frame.width;\n        const uvY = this._pixelSize.y / input._frame.height;\n        let offset;\n\n        if (this._quality === 1 || this._blur === 0)\n        {\n            offset = this._kernels[0] + 0.5;\n            this.uniforms.uOffset[0] = offset * uvX;\n            this.uniforms.uOffset[1] = offset * uvY;\n            filterManager.applyFilter(this, input, output, clear);\n        }\n        else\n        {\n            const renderTarget = filterManager.getFilterTexture();\n\n            let source = input;\n            let target = renderTarget;\n            let tmp;\n\n            const last = this._quality - 1;\n\n            for (let i = 0; i < last; i++)\n            {\n                offset = this._kernels[i] + 0.5;\n                this.uniforms.uOffset[0] = offset * uvX;\n                this.uniforms.uOffset[1] = offset * uvY;\n                filterManager.applyFilter(this, source, target, 1);\n\n                tmp = source;\n                source = target;\n                target = tmp;\n            }\n            offset = this._kernels[last] + 0.5;\n            this.uniforms.uOffset[0] = offset * uvX;\n            this.uniforms.uOffset[1] = offset * uvY;\n            filterManager.applyFilter(this, source, output, clear);\n\n            filterManager.returnFilterTexture(renderTarget);\n        }\n    }\n\n    private _updatePadding()\n    {\n        this.padding = Math.ceil(this._kernels.reduce((acc, v) => acc + v + 0.5, 0));\n    }\n\n    /**\n     * Auto generate kernels by blur & quality\n     * @private\n     */\n    private _generateKernels()\n    {\n        const blur = this._blur;\n        const quality = this._quality;\n        const kernels: number[] = [blur];\n\n        if (blur > 0)\n        {\n            let k = blur;\n            const step = blur / quality;\n\n            for (let i = 1; i < quality; i++)\n            {\n                k -= step;\n                kernels.push(k);\n            }\n        }\n\n        this._kernels = kernels;\n\n        this._updatePadding();\n    }\n\n    /**\n     * The kernel size of the blur filter, for advanced usage.\n     * @default [0]\n     */\n    get kernels(): number[]\n    {\n        return this._kernels;\n    }\n    set kernels(value: number[])\n    {\n        if (Array.isArray(value) && value.length > 0)\n        {\n            this._kernels = value;\n            this._quality = value.length;\n            this._blur = Math.max(...value);\n        }\n        else\n        {\n            // if value is invalid , set default value\n            this._kernels = [0];\n            this._quality = 1;\n        }\n    }\n\n    /**\n     * Get the if the filter is clampped.\n     *\n     * @readonly\n     * @default false\n     */\n    get clamp(): boolean\n    {\n        return this._clamp;\n    }\n\n    /**\n     * Sets the pixel size of the filter. Large size is blurrier. For advanced usage.\n     *\n     * @member {PIXI.Point|number[]}\n     * @default [1, 1]\n     */\n    set pixelSize(value: PixelSizeValue)\n    {\n        if (typeof value === 'number')\n        {\n            this._pixelSize.x = value;\n            this._pixelSize.y = value;\n        }\n        else if (Array.isArray(value))\n        {\n            this._pixelSize.x = value[0];\n            this._pixelSize.y = value[1];\n        }\n        else if (value instanceof Point)\n        {\n            this._pixelSize.x = value.x;\n            this._pixelSize.y = value.y;\n        }\n        else\n        {\n            // if value is invalid , set default value\n            this._pixelSize.x = 1;\n            this._pixelSize.y = 1;\n        }\n    }\n    get pixelSize(): PixelSizeValue\n    {\n        return this._pixelSize;\n    }\n\n    /**\n     * The quality of the filter, integer greater than `1`.\n     * @default 3\n     */\n    get quality(): number\n    {\n        return this._quality;\n    }\n    set quality(value: number)\n    {\n        this._quality = Math.max(1, Math.round(value));\n        this._generateKernels();\n    }\n\n    /**\n     * The amount of blur, value greater than `0`.\n     * @default 4\n     */\n    get blur(): number\n    {\n        return this._blur;\n    }\n    set blur(value: number)\n    {\n        this._blur = value;\n        this._generateKernels();\n    }\n}\n\nexport { KawaseBlurFilter };\nexport type { PixelSizeValue };\n"],"names":["KawaseBlurFilter","Filter","blur","quality","clamp","vertex","fragmentClamp","fragment","Point","filterManager","input","output","clear","uvX","uvY","offset","renderTarget","source","target","tmp","last","i","acc","v","kernels","k","step","value"],"mappings":"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"}